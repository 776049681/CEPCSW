/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
#include "CaloDigiAlg.h"


#include "edm4hep/SimCalorimeterHit.h"
#include "edm4hep/CalorimeterHit.h"
#include "edm4hep/Vector3f.h"

#include "DD4hep/Detector.h"
#include <DD4hep/Objects.h>
#include <DDRec/DetectorData.h>
#include <DDRec/CellIDPositionConverter.h>


#include <cmath>
#include <algorithm>

DECLARE_COMPONENT( CaloDigiAlg )

CaloDigiAlg::CaloDigiAlg(const std::string& name, ISvcLocator* svcLoc)
  : GaudiAlgorithm(name, svcLoc),
    _nEvt(0)
{
  
  // Input collections
  declareProperty("SimCaloHitCollection", r_SimCaloCol, "Handle of the Input SimCaloHit collection");
  
  // Output collections
  declareProperty("CaloHitCollection", w_DigiCaloCol, "Handle of Digi CaloHit collection");
  
   
}

StatusCode CaloDigiAlg::initialize()
{

  std::cout<<"CaloDigiAlg::m_scale="<<m_scale<<std::endl;
  m_geosvc = service<IGeoSvc>("GeoSvc");
  if ( !m_geosvc )  throw "CaloDigiAlg :Failed to find GeoSvc ...";
  dd4hep::Detector* m_dd4hep = m_geosvc->lcdd();
  if ( !m_dd4hep )  throw "CaloDigiAlg :Failed to get dd4hep::Detector ...";
  m_cellIDConverter = new dd4hep::rec::CellIDPositionConverter(*m_dd4hep);
  try{
      const dd4hep::DetElement &detElement = m_dd4hep->detector("CaloDetector");
      dd4hep::rec::LayeredCalorimeterData* Data = detElement.extension<dd4hep::rec::LayeredCalorimeterData>() ;
      const std::vector<dd4hep::rec::LayeredCalorimeterData::Layer>& layerLayout = Data->layers;
      assert(layerLayout.size()>=1);
      float cellSize0     = layerLayout.at(0).cellSize0;
      float cellSize1     = layerLayout.at(0).cellSize1;
      float cellThickness = layerLayout.at(0).sensitive_thickness;
      m_length = sqrt(cellSize0*cellSize0 + cellSize1*cellSize1 + cellThickness*cellThickness);
      std::cout<<"CaloDigiAlg::cellSize0="<<cellSize0<<",cellSize1="<<cellSize1<<",cellThickness="<<cellThickness<<",m_length="<<m_length<<std::endl;
  }
  catch(...) 
  {
      throw "CaloDigiAlg :Failed to get LayeredCalorimeterData ...";
  }
  return GaudiAlgorithm::initialize();
}

StatusCode CaloDigiAlg::execute()
{
  std::vector< edm4hep::SimCalorimeterHit > sim_vec;
  std::map<unsigned long long, edm4hep::SimCalorimeterHit> id_hit_map;
  std::map<unsigned long long, int > test_map;
  edm4hep::CalorimeterHitCollection* caloVec   = w_DigiCaloCol.createAndPut();
  const edm4hep::SimCalorimeterHitCollection* SimHitCol =  r_SimCaloCol.get();
  if(SimHitCol == 0) 
  {
     std::cout<<"not found SimCalorimeterHitCollection"<< std::endl;
     return StatusCode::SUCCESS;
  }
  std::cout<<"digi, input sim hit size="<< SimHitCol->size() <<std::endl;
  float tot_sim_en = 0;
  for( int i = 0; i < SimHitCol->size(); i++ ) 
  {
      int index = -1;
      float dis_min = m_length;//10mm*10mm*10mm
      bool found = false;
      edm4hep::SimCalorimeterHit SimHit = SimHitCol->at(i);
      float en = SimHit.getEnergy();
      tot_sim_en += en;
      float x0 = SimHit.getPosition().x ;
      float y0 = SimHit.getPosition().y ;
      float z0 = SimHit.getPosition().z ;
      //std::cout<<"x0="<<x0<<",y0="<<y0<<",z0="<<z0<<std::endl;
      for(int j=0; j<sim_vec.size(); j++)
      {
          float x = sim_vec.at(j).getPosition().x ;
          float y = sim_vec.at(j).getPosition().y ;
          float z = sim_vec.at(j).getPosition().z ;
          float dist  = sqrt( (x-x0)*(x-x0) + (y-y0)*(y-y0) + (z-z0)*(z-z0) );
          if( dist < dis_min ){ dis_min = dist; index = j ; }
      }
      if(index==-1) sim_vec.push_back(SimHit);
      else  
      {   
          float en_ori = sim_vec.at(index).getEnergy();
          float sum_en = en + en_ori ;          
          sim_vec.at(index).setEnergy(sum_en);
          //std::cout<<"ori_x="<<sim_vec.at(index).getPosition().x<<",ori_y="<<sim_vec.at(index).getPosition().y<<",ori_z="<<sim_vec.at(index).getPosition().z<<std::endl;
          float new_x = sim_vec.at(index).getPosition().x * en_ori/sum_en + SimHit.getPosition().x * en/sum_en;
          float new_y = sim_vec.at(index).getPosition().y * en_ori/sum_en + SimHit.getPosition().y * en/sum_en;
          float new_z = sim_vec.at(index).getPosition().z * en_ori/sum_en + SimHit.getPosition().z * en/sum_en;
          edm4hep::Vector3f pos(new_x, new_y, new_z);
          sim_vec.at(index).setPosition(pos);
          //std::cout<<"new_x="<<sim_vec.at(index).getPosition().x<<",new_y="<<sim_vec.at(index).getPosition().y<<",new_z="<<sim_vec.at(index).getPosition().z<<std::endl;
      }
  }
  float tot_en = 0;
  for(std::vector< edm4hep::SimCalorimeterHit >::iterator iter = sim_vec.begin(); iter != sim_vec.end(); iter++)
  {
    auto caloHit = caloVec->create();
    caloHit.setCellID  (iter->getCellID());
    caloHit.setEnergy  (iter->getEnergy()*m_scale);
    caloHit.setPosition(iter->getPosition());
    tot_en += caloHit.getEnergy();
  }
    
  std::cout<<"total sim e ="<< tot_sim_en <<std::endl;
  std::cout<<"digi, output digi hit size="<< caloVec->size()<<",tot_en="<<tot_en <<std::endl;
  _nEvt ++ ;

  return StatusCode::SUCCESS;
}

StatusCode CaloDigiAlg::finalize()
{
  info() << "Processed " << _nEvt << " events " << endmsg;
  return GaudiAlgorithm::finalize();
}
